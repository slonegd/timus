/**
 * 1196. Экзамен по истории
 * Ограничение времени: 1.5 секунды
 * Ограничение памяти: 64 МБ
 * Будем справедливы: сессия ставит задачи не только студентам,
 * но и преподавателям. Любой преподаватель обучает немалое
 * количество студентов, а ведь каждого надо еще и проверить.
 * Поэтому один из преподавателей решил принимать экзамен по
 * истории по такой упрощённой процедуре: студент записывает
 * все известные ему «исторические» даты (достаточно, чтобы он
 * написал только года, но, конечно, мог объяснить, чем
 * замечательна та или иная дата). Преподаватель же держит
 * перед глазами список дат, которые студент должен знать.
 * Для оценки знаний студента преподаватель подсчитывает
 * количество чисел в списке студента, которые также есть в
 * списке преподавателя. В зависимости от полученного числа
 * и выставляется итоговая оценка.
 * Вы должны оказать посильную помощь в автоматизации этого
 * процесса, разработав программу для подсчёта количества
 * совпадений в списках студента и преподавателя.
 * 
 * Исходные данные
 * В первой строке содержится число N — количество записей
 * в списке преподавателя. 1 ≤ N ≤ 15000. Затем идет N строк,
 * содержащих список преподавателя, по одной дате в строке.
 * Записаны только года. Каждый год — целое число в пределах
 * от 1 до 10^9. Даты в этом списке отсортированы по неубыванию.
 * В следующей после списка строке содержится число M —
 * количество записей в списке студента, 1 ≤ M ≤ 10^6.
 * Затем также M строк с датами (записаны только года,
 * каждый год — целое число в пределах от 1 до 10^9).
 * Этот список не отсортирован. В списке как студента,
 * так и преподавателя даты могут повторяться.
 * 
 * Результат
 * Вы должны вывести одно число — количество чисел во втором списке,
 * которые также содержатся в первом.
 * 
 * Пример
 * исходные данные	
 * 2
 * 1054
 * 1492
 * 4
 * 1492
 * 65536
 * 1492
 * 100
 * результат
 * 2
 */

#include <iostream>
#include <vector>
#include <algorithm>

int main()
{
    std::ios::sync_with_stdio(false);
    int N, tmp, res;
    std::vector<int> teacher;

    std::cin >> N;
    teacher.reserve (N);
    while (N--) {
        std::cin >> tmp;
        teacher.emplace_back (tmp);
    }

    res = 0;

    std::cin >> N;
    while (N--) {
        std::cin >> tmp;
        res += static_cast<int>(
            std::binary_search (
                std::cbegin(teacher),
                std::cend(teacher),
                tmp
            )
        );
    }

    std::cout << res << std::endl;
}