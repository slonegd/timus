/**
 * 1243. Развод семи гномов
 * Все мы знаем, чем закончилась история про Белоснежку и семь гномов —
 * Белоснежка уехала с женихом, бросив всех тех, кто бескорыстно помог
 * ей в трудную пору. После её отъезда гномы стали ссориться — каждый
 * считал, что другие чем-то обидели Белоснежку.
 * Чтобы не доводить вечные ссоры до кровопролития, некогда дружные
 * гномы решили расстаться, поделив все свое добро, от кружек до алмазов,
 * согласно старинным гномьим законам о разводе. По этим законам, все
 * имущество должно быть самым справедливым образом поделено между
 * гномами, а то, что поделить поровну нельзя, не должно достаться никому
 * из них. Бережливые гномы решили, что неразделённые вещи выкидывать
 * не будут, а отдадут Белоснежке в качестве приданого.
 * Например, у каждого из гномов с рождения имелось по две пары ботинок,
 * к моменту появления этой задачи самый старый гном одну свою пару
 * износил, значит, после справедливого раздела оставшихся 26 ботинок,
 * каждый гном получит по 3 ботинка, а Белоснежку осчастливят 5 ботинками.
 * Отметим, что некоторых вещей у гномов очень много — одних только
 * маковых зёрнышек накопилось 123456123456 штук. Гномы потратили немало
 * времени, пока сосчитали, что Белоснежка получит всего одно маковое
 * зёрнышко. Ваша задача — помочь гномам рассчитать долю Белоснежки.
 * 
 * Исходные данные
 * Единственная строка содержит число N одинаковых вещей, которые хотят
 * поделить гномы (1 ≤ N ≤ 10^50).
 * 
 * Результат
 * Единственное число — количество вещей, которые в результате
 * справедливого раздела, перейдут к Белоснежке.
 * 
 * Пример
 * исходные данные   результат
 * 123456123456      1
 */

#include <iostream>
#include <string>
#include <vector>
#include <cmath>

struct BigNum
{
    std::vector<int> decimal;

    BigNum (std::string s)
    {
        decimal.reserve(s.size());
        while (s.size()) {
            decimal.push_back (s.back() - '0');
            s.pop_back();
        }
    }

    BigNum operator-- (int)
    {
        size_t i = 0;
        do {
            this->decimal[i]--;
            decimal[i] = std::min(9,decimal[i]);
        } while (this->decimal[i++] == 9);

        return *this;
    }

    int mod7()
    {
        // Берётся первая слева цифра, умножается на 3, прибавляется следующая,
        // и всё повторяется сначала:
        // например, для 154: 1 ⋅ 3 + 5 = 8 , 8 ⋅ 3 + 4 = 28.
        // Также на каждом шаге можно брать остаток от деления на 7:
        // 1 ⋅ 3 + 5 = 8 остаток 1, 1 ⋅ 3 + 4 = 7 остаток 0.
        // В обоих случаях итоговое число равноостаточно при делении на 7 с исходным числом.
        auto it = decimal.rbegin();
        int res = *it;
        for (it = std::next(it); it != decimal.rend(); ++it) {
            res = (res*3 + *it) % 7;
        }
        return res;
    }

    // friend std::ostream& operator << (std::ostream& s, const BigNum& n)
    // {
    //     for (auto it = n.decimal.rbegin(); it != n.decimal.rend(); ++it)
    //         s << *it;
    //     return s;
    // }
};

int main()
{
    std::ios::sync_with_stdio(false);

    std::string s;
    std::cin >> s;

    auto number = BigNum(s);
    std::cout << number.mod7() << std::endl;

}